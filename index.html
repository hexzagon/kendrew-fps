<!DOCTYPE html>
<html>
<head>
  <title>PROJECT : HEXAGON</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    #menu {
      position: absolute;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: white;
      font-family: Arial;
      background: black;
    }
    button {
      padding: 15px 30px;
      font-size: 20px;
      cursor: pointer;
    }
  </style>
</head>
<body>

<div id="menu">
  <h1>PROJECT : HEXAGON</h1>
  <button onclick="startGame()">START</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>

<script>

let scene, camera, renderer;
let enemies = [];
let walls = [];

let keys = {};
let yaw = 0;
let pitch = 0;
let playerSpeed = 0.12;

function startGame(){
  document.getElementById("menu").style.display = "none";
  init();
  animate();
}

function init(){

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x111111);

  camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth/window.innerHeight,
    0.1,
    1000
  );
  camera.position.set(0,1.6,5);

  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const light = new THREE.HemisphereLight(0xffffff,0x444444);
  scene.add(light);

  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(100,100),
    new THREE.MeshStandardMaterial({color:0x222222})
  );
  floor.rotation.x = -Math.PI/2;
  scene.add(floor);

  spawnWall(0,-5);
  spawnWall(5,-5);
  spawnWall(-5,-5);

  spawnEnemy(5,1,-10);
  spawnEnemy(-5,1,-15);

  setupControls();
}

function spawnWall(x,z){
  const wall = new THREE.Mesh(
    new THREE.BoxGeometry(4,3,1),
    new THREE.MeshStandardMaterial({color:0x555555})
  );
  wall.position.set(x,1.5,z);
  scene.add(wall);
  walls.push(wall);
}

function spawnEnemy(x,y,z){

  const body = new THREE.Mesh(
    new THREE.BoxGeometry(1,2,1),
    new THREE.MeshStandardMaterial({color:0xff0000})
  );

  const head = new THREE.Mesh(
    new THREE.SphereGeometry(0.4),
    new THREE.MeshStandardMaterial({color:0xffff00})
  );

  head.position.set(0,1.2,0);
  body.add(head);
  body.position.set(x,y,z);

  body.userData = {
    health:100,
    state:"idle",
    awareTimer:0
  };

  scene.add(body);
  enemies.push(body);
}

function setupControls(){

  document.addEventListener("keydown", e=>keys[e.key.toLowerCase()] = true);
  document.addEventListener("keyup", e=>keys[e.key.toLowerCase()] = false);

  document.body.addEventListener("click", ()=>{
    document.body.requestPointerLock();
    shoot();
  });

  document.addEventListener("mousemove", (e)=>{
    if(document.pointerLockElement === document.body){
      yaw -= e.movementX * 0.002;
      pitch -= e.movementY * 0.002;
      pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2,pitch));
    }
  });
}

function updatePlayer(){

  camera.rotation.order = "YXZ";
  camera.rotation.y = yaw;
  camera.rotation.x = pitch;

  let forward = new THREE.Vector3();
  camera.getWorldDirection(forward);
  forward.y = 0;
  forward.normalize();

  let right = new THREE.Vector3();
  right.crossVectors(forward, camera.up).normalize();

  if(keys["w"]) camera.position.add(forward.clone().multiplyScalar(playerSpeed));
  if(keys["s"]) camera.position.add(forward.clone().multiplyScalar(-playerSpeed));
  if(keys["a"]) camera.position.add(right.clone().multiplyScalar(-playerSpeed));
  if(keys["d"]) camera.position.add(right.clone().multiplyScalar(playerSpeed));
}

function canSeePlayer(enemy){
  const ray = new THREE.Raycaster();
  const dir = camera.position.clone().sub(enemy.position).normalize();
  ray.set(enemy.position, dir);

  const intersects = ray.intersectObjects([...walls]);

  if(intersects.length === 0){
    return true;
  }

  return false;
}

function updateEnemies(){
  enemies.forEach(enemy=>{

    if(canSeePlayer(enemy)){
      enemy.userData.state = "alert";
      enemy.userData.awareTimer = 3600;
    }

    if(enemy.userData.state === "alert"){
      const dir = camera.position.clone().sub(enemy.position).normalize();
      enemy.position.add(dir.multiplyScalar(0.03));

      enemy.userData.awareTimer--;
      if(enemy.userData.awareTimer <=0){
        enemy.userData.state = "idle";
      }
    }
  });
}

function shoot(){

  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(new THREE.Vector2(0,0), camera);

  const intersects = raycaster.intersectObjects(enemies,true);

  if(intersects.length>0){

    const hit = intersects[0].object;
    const enemy = hit.parent || hit;

    if(hit.geometry.type === "SphereGeometry"){
      scene.remove(enemy);
      enemies = enemies.filter(e=>e!==enemy);
    } else {
      enemy.userData.health -=50;
      enemy.userData.state="alert";
      if(enemy.userData.health <=0){
        scene.remove(enemy);
        enemies = enemies.filter(e=>e!==enemy);
      }
    }
  }
}

function animate(){
  requestAnimationFrame(animate);
  updatePlayer();
  updateEnemies();
  renderer.render(scene,camera);
}

</script>

</body>
</html>
